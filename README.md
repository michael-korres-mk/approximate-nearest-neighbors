# approximate-nearest-neighbors - Kyndinis Marios - sdi2000223 & Korres Michail - sdi2000092 - uoa - di

### Build Project
```
make
```

### Run Project
```
make ann
```

### Run Project with Valgrind
```
make valgrind-ann
```

### Clean
```
make clean
```

## About the project

### Introduction

Στην παρούσα υλοποίηση αναπτύξαμε έναν αλγόριθμο βασισμένο στο Vamana για την αποδοτική εύρεση των κατά προσέγγιση πλησιέστερων γειτόνων σε μεγάλα σύνολα δεδομένων υψηλής διάστασης. Εστιάσαμε ιδιαίτερα στη βασική μέθοδο vamana(), η οποία αποτελεί τον πυρήνα του αλγορίθμου μας και καθορίζει την αποτελεσματικότητά του.

Η μέθοδος vamana() είναι υπεύθυνη για την κατασκευή του γράφου. Αρχικά, μέσω της initializeRandomEdges(), αρχικοποιήσαμε τον γράφο με τυχαίες ακμές, εξασφαλίζοντας ότι κάθε κόμβος έχει ένα αρχικό σύνολο γειτόνων και ότι ο γράφος είναι συνδεδεμένος. Στη συνέχεια, υπολογίσαμε το medoid του συνόλου δεδομένων με τη μέθοδο medoid(), η οποία επιλέγει ένα σημείο που ελαχιστοποιεί τη συνολική απόσταση από τα υπόλοιπα σημεία.

Στον κύριο βρόχο της vamana(), για κάθε κόμβο που δεν έχει ακόμα επεξεργαστεί, εκτελέσαμε μια άπληστη αναζήτηση ξεκινώντας από το medoid, χρησιμοποιώντας τη μέθοδο greedySearch(). Η greedySearch() ξεκινά από έναν αρχικό κόμβο s και αναζητά τους πλησιέστερους γείτονες για ένα δοσμένο διάνυσμα ερώτησης q. Χρησιμοποιήσαμε μια δομή VamanaContainer l για να αποθηκεύουμε τους υποψήφιους κόμβους με βάση την απόστασή τους από το q, και ένα σύνολο V για τους κόμβους που έχουν ήδη επισκεφθεί. Με αυτόν τον τρόπο, διατηρήσαμε ένα ισορροπημένο σύνολο υποψήφιων κόμβων προς εξέταση, αποφεύγοντας επανειλημμένες επισκέψεις και βελτιστοποιώντας την απόδοση.

Κατά την αναζήτηση, επεκτείναμε το σύνολο l με τους γείτονες του τρέχοντος κόμβου που δεν είχαν ήδη επισκεφθεί. Επιλέγαμε τον κόμβο με τη μικρότερη απόσταση από το q και επαναλαμβάναμε τη διαδικασία μέχρι να μην υπάρχουν άλλοι υποψήφιοι κόμβοι. Αυτό επέτρεψε την αποδοτική πλοήγηση στον γράφο και την εύρεση των πιο σχετικών κόμβων σε σχέση με το q.

Μετά την ολοκλήρωση της άπληστης αναζήτησης για έναν κόμβο, εφαρμόσαμε τη μέθοδο robustPrune() για να βελτιστοποιήσουμε το σύνολο των γειτόνων του. Η μέθοδος robustPrune() δέχεται ως είσοδο έναν κόμβο p, ένα σύνολο υποψήφιων γειτόνων V, την παράμετρο α, και το μέγιστο επιτρεπτό βαθμό R. Μέσω αυτής της διαδικασίας, εφαρμόζουμε ένα κλάδεμα στους υποψήφιους γείτονες ώστε να διατηρήσουμε μόνο τους πιο σημαντικούς, βάσει της απόστασης και του κατωφλίου α. Συγκεκριμένα, επιλέγουμε τον πλησιέστερο γείτονα και αφαιρούμε από το σύνολο των υποψήφιων όσους δεν πληρούν το κριτήριο απόστασης που ορίζει το α. Αυτό μας επέτρεψε να διατηρήσουμε τον γράφο αραιό αλλά ταυτόχρονα αποδοτικό για την αναζήτηση, καθώς περιορίζει τον αριθμό των ακμών ανά κόμβο χωρίς να θυσιάζει την ποιότητα της αναζήτησης. Έτσι, εξασφαλίζουμε ότι κάθε κόμβος συνδέεται με τους πιο σχετικούς γείτονες, βελτιώνοντας την ταχύτητα και την ακρίβεια του αλγορίθμου.

Κατά την αξιολόγηση της απόδοσης του αλγορίθμου, φορτώσαμε τα σύνολα δεδομένων βάσης, ερωτήσεων και ground truth χρησιμοποιώντας την κλάση DataSet. Για κάθε διάνυσμα ερώτησης, εκτελέσαμε την αναζήτηση στον γράφο και συγκρίναμε τα αποτελέσματα με το ground truth. Υπολογίσαμε το k-recall, που είναι το ποσοστό των πραγματικών πλησιέστερων γειτόνων που βρέθηκαν από τον αλγόριθμο. Τα αποτελέσματα έδειξαν υψηλό επίπεδο ακρίβειας, επιβεβαιώνοντας την αποτελεσματικότητα της προσέγγισής μας.

Στον κώδικα, χρησιμοποιήσαμε επίσης την κλάση Utils για διάφορες βοηθητικές λειτουργίες, όπως η δημιουργία τυχαίων αριθμών και η εκτύπωση διαχωριστικών γραμμών για την καλύτερη αναγνωσιμότητα των εξόδων. Επιπλέον, επιλέξαμε να χρησιμοποιήσουμε πρότυπα (templates) για την κλάση Graph, ώστε να υποστηρίζουμε διαφορετικούς τύπους δεδομένων χωρίς να χρειάζεται να επαναλάβουμε τον κώδικα.

Δώσαμε ιδιαίτερη προσοχή στη διαχείριση της μνήμης και την αποφυγή διαρροών, χρησιμοποιώντας κατάλληλες δομές δεδομένων και εξασφαλίζοντας ότι όλες οι δυναμικές μνήμες απελευθερώνονται σωστά. Ο συνάδελφός μου και εγώ φροντίσαμε ο κώδικας να είναι καλά σχολιασμένος και δομημένος, ώστε να είναι εύκολα κατανοητός και επεκτάσιμος στο μέλλον.

## Unit Tests
### Build Project-Unit Test
```
make
```

### Run Unit Test
```
make tests
```
### Description
