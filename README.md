# approximate-nearest-neighbors - Kyndinis Marios - sdi2000223 & Korres Michail - sdi2000092 - uoa - di

### Build Project
```
make b
```

### Run A Target
```
make ann
```
```
make filterann
```

#### NOTE \#1
In the configs/filterann.mk.config: \
FILTERANN_FVAMANA = 0 => Stitched Vamana \
FILTERANN_FVAMANA = 1 => Filtered Vamana

#### NOTE \#2
If corresponding precomputed graph file exists in src/main/resources,\
then the graph will **automatically get imported**,instead of calculated from scratch.\
Delete the corresponding file {vamana_graph.bin,stitched_vamana_graph.bin,filtered_vamana_graph.bin} to run the algorithms.


```
make groundtruthcalc
```

### Build Specific Target
#### Just add a **b** to the target ==> {ann => ann**b**}

### Run Target with Valgrind
#### Just add a **v** to the target ==> {ann => ann**v**}

### Clean
```
make clean
```
--------------
### Project Contribution

#### Michael Korres
* Software Design
* Build Mechanism and API Design & Implementation
* Project Setup (Project File-Structure, Data Input & Core Implementations)
* GreedySearch Implementation
* Vamana Implementation
* FilteredGreedySearch Implementation
* StitchedVamana Implementation
* CI Pipeline

#### Marios Kindynis
* RobustPrune Implementation
* Implementation Optimizations & Fixes
* Testing
* Commenting & README
* FindMedoid Implementation
* FilteredVamana Implementation
* FilteredRobustPrune Implementation

--------------

## About the project

### Introduction

Στην παρούσα υλοποίηση αναπτύξαμε έναν αλγόριθμο βασισμένο στο Vamana για την αποδοτική εύρεση των κατά προσέγγιση πλησιέστερων γειτόνων σε μεγάλα σύνολα δεδομένων υψηλής διάστασης. Εστιάσαμε ιδιαίτερα στη βασική μέθοδο vamana(), η οποία αποτελεί τον πυρήνα του αλγορίθμου μας και καθορίζει την αποτελεσματικότητά του.

### Description of the Algorithm

Η μέθοδος vamana() είναι υπεύθυνη για την κατασκευή του γράφου. Αρχικά, μέσω της initializeRandomEdges(), αρχικοποιήσαμε τον γράφο με τυχαίες ακμές, εξασφαλίζοντας ότι κάθε κόμβος έχει ένα αρχικό σύνολο γειτόνων και ότι ο γράφος είναι συνδεδεμένος. Στη συνέχεια, υπολογίσαμε το medoid του συνόλου δεδομένων με τη μέθοδο medoid(), η οποία επιλέγει ένα σημείο που ελαχιστοποιεί τη συνολική απόσταση από τα υπόλοιπα σημεία.

Στον κύριο βρόχο της vamana(), για κάθε κόμβο που δεν έχει ακόμα επεξεργαστεί, εκτελέσαμε μια άπληστη αναζήτηση ξεκινώντας από το medoid, χρησιμοποιώντας τη μέθοδο greedySearch(). Η greedySearch() ξεκινά από έναν αρχικό κόμβο s και αναζητά τους πλησιέστερους γείτονες για ένα δοσμένο διάνυσμα ερώτησης q. Χρησιμοποιήσαμε μια δομή VamanaContainer l για να αποθηκεύουμε τους υποψήφιους κόμβους με βάση την απόστασή τους από το q, και ένα σύνολο V για τους κόμβους που έχουν ήδη επισκεφθεί. Με αυτόν τον τρόπο, διατηρήσαμε ένα ισορροπημένο σύνολο υποψήφιων κόμβων προς εξέταση, αποφεύγοντας επανειλημμένες επισκέψεις και βελτιστοποιώντας την απόδοση.

Κατά την αναζήτηση, επεκτείναμε το σύνολο l με τους γείτονες του τρέχοντος κόμβου που δεν είχαν ήδη επισκεφθεί. Επιλέγαμε τον κόμβο με τη μικρότερη απόσταση από το q και επαναλαμβάναμε τη διαδικασία μέχρι να μην υπάρχουν άλλοι υποψήφιοι κόμβοι. Αυτό επέτρεψε την αποδοτική πλοήγηση στον γράφο και την εύρεση των πιο σχετικών κόμβων σε σχέση με το q.

Μετά την ολοκλήρωση της άπληστης αναζήτησης για έναν κόμβο, εφαρμόσαμε τη μέθοδο robustPrune() για να βελτιστοποιήσουμε το σύνολο των γειτόνων του. Η μέθοδος robustPrune() δέχεται ως είσοδο έναν κόμβο p, ένα σύνολο υποψήφιων γειτόνων V, την παράμετρο α, και το μέγιστο επιτρεπτό βαθμό R. Μέσω αυτής της διαδικασίας, εφαρμόζουμε ένα κλάδεμα στους υποψήφιους γείτονες ώστε να διατηρήσουμε μόνο τους πιο σημαντικούς, βάσει της απόστασης και του κατωφλίου α. Συγκεκριμένα, επιλέγουμε τον πλησιέστερο γείτονα και αφαιρούμε από το σύνολο των υποψήφιων όσους δεν πληρούν το κριτήριο απόστασης που ορίζει το α. Αυτό μας επέτρεψε να διατηρήσουμε τον γράφο αραιό αλλά ταυτόχρονα αποδοτικό για την αναζήτηση, καθώς περιορίζει τον αριθμό των ακμών ανά κόμβο χωρίς να θυσιάζει την ποιότητα της αναζήτησης. Έτσι, εξασφαλίζουμε ότι κάθε κόμβος συνδέεται με τους πιο σχετικούς γείτονες, βελτιώνοντας την ταχύτητα και την ακρίβεια του αλγορίθμου.

Κατά την αξιολόγηση της απόδοσης του αλγορίθμου, φορτώσαμε τα σύνολα δεδομένων βάσης, ερωτήσεων και ground truth χρησιμοποιώντας την κλάση DataSet. Για κάθε διάνυσμα ερώτησης, εκτελέσαμε την αναζήτηση στον γράφο και συγκρίναμε τα αποτελέσματα με το ground truth. Υπολογίσαμε το k-recall, που είναι το ποσοστό των πραγματικών πλησιέστερων γειτόνων που βρέθηκαν από τον αλγόριθμο. Τα αποτελέσματα έδειξαν υψηλό επίπεδο ακρίβειας, επιβεβαιώνοντας την αποτελεσματικότητα της προσέγγισής μας.

Στον κώδικα, χρησιμοποιήσαμε επίσης την κλάση Utils για διάφορες βοηθητικές λειτουργίες, όπως η δημιουργία τυχαίων αριθμών και η εκτύπωση διαχωριστικών γραμμών για την καλύτερη αναγνωσιμότητα των εξόδων. Επιπλέον, επιλέξαμε να χρησιμοποιήσουμε πρότυπα (templates) για την κλάση Graph, ώστε να υποστηρίζουμε διαφορετικούς τύπους δεδομένων χωρίς να χρειάζεται να επαναλάβουμε τον κώδικα.

Δώσαμε ιδιαίτερη προσοχή στη διαχείριση της μνήμης και την αποφυγή διαρροών, χρησιμοποιώντας κατάλληλες δομές δεδομένων και εξασφαλίζοντας ότι όλες οι δυναμικές μνήμες απελευθερώνονται σωστά. Ο συνάδελφός μου και εγώ φροντίσαμε ο κώδικας να είναι καλά σχολιασμένος και δομημένος, ώστε να είναι εύκολα κατανοητός και επεκτάσιμος στο μέλλον.

### Changes and Additions for the Second Deliverable
Στην παρούσα επέκταση για το δεύτερο παραδοτέο, προσαρμόσαμε τον αλγόριθμο και τις δομές δεδομένων μας ώστε να υποστηρίζουν φιλτραρισμένες ερωτήσεις (filtered queries). Αυτό μας επιτρέπει να εκτελούμε αναζητήσεις εγγύτερων γειτόνων όχι μόνο με βάση την ευκλείδεια απόσταση, αλλά και υπό την προϋπόθ**εση ότι τα σημεία δεδομένων ανήκουν σε συγκεκριμένες κατηγορίες ή φέρουν ορισμένες ετικέτες (filters).

Πιο συγκεκριμένα, εισαγάγαμε τους ακόλουθους αλγόριθμους:**
1. Find Medoid: επιλέγει ένα medoid για κάθε φίλτρο εφαρμόζοντας τυχαία δειγματοληψία στα σχετικά σημεία δεδομένων. Αρχικά, ομαδοποιεί τα σημεία ανά φίλτρο και αντλεί τυχαία δείγματα με βάση το μέγεθος του tau. Στη συνέχεια, επιλέγει ως medoid εκείνο το σημείο που έχει χρησιμοποιηθεί λιγότερο φορές ως medoid στο παρελθόν, ώστε να κατανεμηθεί ισορροπημένα το “φορτίο”. Τέλος, ενημερώνει τους σχετικούς χάρτες (M, medoidCount) καταγράφοντας το επιλεγμένο medoid για κάθε φίλτρο.
2. Filtered Greedy Search: Η κλασική greedySearch() προσαρμόστηκε ώστε να λαμβάνει υπόψη φίλτρα κατά τη διάρκεια της αναζήτησης. Πλέον, σε κάθε βήμα εξετάζονται μόνο οι κόμβοι που ικανοποιούν τα κριτήρια φιλτραρίσματος, εξασφαλίζοντας ότι το αποτέλεσμα περιλαμβάνει μόνο εκείνα τα σημεία που πληρούν τις απαιτούμενες ετικέτες. 
3. Filtered Robust Prune: Η διαδικασία robustPrune() προσαρμόστηκε σε filteredRobustPrune() ώστε να λαμβάνει υπόψη το σύνολο φίλτρων κατά το κλάδεμα των ακμών. Αυτό εξασφαλίζει ότι, εκτός από το κριτήριο απόστασης, τα διατηρούμενα ακριακά σημεία έχουν τουλάχιστον μία κοινή ετικέτα με τον κόμβο αναφοράς. Έτσι, ο γράφος παραμένει αραιός και σχετικός με τα φίλτρα, χωρίς να θυσιάζεται η ποιότητα των αναζητήσεων. 
4. Filtered Vamana: Επεκτείναμε τον αλγόριθμο κατασκευής του ευρετηρίου (Vamana) για να υποστηρίζει τη δημιουργία φιλτραρισμένων γραφημάτων. Στην υλοποίηση της filteredVamana(), εκτελούμε τοπικές αναζητήσεις με φίλτρα (FilteredGreedySearch) και στη συνέχεια εφαρμόζουμε την προσαρμοσμένη διαδικασία κλαδέματος (FilteredRobustPrune) για να διατηρούμε μόνο τους σχετικούς γείτονες με βάση τα φίλτρα. Με αυτόν τον τρόπο, εξασφαλίζουμε ότι οι ακμές του γράφου συνδέουν κόμβους που μοιράζονται τις ίδιες ετικέτες, βελτιώνοντας την ακρίβεια και την ταχύτητα των μελλοντικών φιλτραρισμένων αναζητήσεων.
5. Stitched Vamana: Σε περιπτώσεις όπου υπάρχουν πολλαπλά φίλτρα, χρησιμοποιούμε τον αλγόριθμο stitchedVamana() για να ενοποιήσουμε τα επιμέρους ευρετήρια που έχουν κατασκευαστεί χωριστά για κάθε φίλτρο. Με την ολοκλήρωση της διαδικασίας, και αφού εφαρμόσουμε το FilteredRobustPrune, επιτυγχάνουμε έναν τελικό, συνεκτικό γράφο ευρετηρίου ικανό να υποστηρίζει αναζητήσεις με πολλαπλά φίλτρα.

Με αυτές τις αλλαγές, το σύστημά μας δεν περιορίζεται πλέον στην απλή αναζήτηση κατά προσέγγιση πλησιέστερων γειτόνων, αλλά υποστηρίζει και φιλτραρισμένες αναζητήσεις, επιτρέποντάς μας να περιορίσουμε τον χώρο αναζήτησης και να βελτιώσουμε περαιτέρω το recall σε ερωτήματα που αφορούν συγκεκριμένες κατηγορίες δεδομένων. Η αρχιτεκτονική παραμένει επεκτάσιμη και ευέλικτη, διευκολύνοντας τη μελλοντική προσθήκη επιπλέον κριτηρίων ή φίλτρων.

--------------

## Unit Tests
### Build Test Targets
```
make testb
```

### Run Tests
```
make test
```

### Description

Για την υλοποίηση των unit tests, δημιουργήσαμε ένα Makefile που αυτοματοποιεί τη διαδικασία κατασκευής και εκτέλεσης των δοκιμών μας. Το Makefile εντοπίζει όλα τα αρχεία .cpp στον φάκελο tests και δημιουργεί τα αντίστοιχα εκτελέσιμα στον φάκελο build/tests. Έτσι, με μία μόνο εντολή, μπορούμε να κατασκευάσουμε και να εκτελέσουμε όλα τα tests, εξοικονομώντας χρόνο και αποφεύγοντας πιθανά λάθη. Με αυτόν τον τρόπο, μπορούμε να προσθέτουμε νέα tests απλά δημιουργώντας ένα νέο αρχείο .cpp στον φάκελο tests, χωρίς να χρειάζεται να τροποποιούμε το Makefile.

Χρησιμοποιήσαμε τη βιβλιοθήκη acutest.h για τη συγγραφή των unit tests. Το acutest.h μας παρέχει ένα απλό και ευέλικτο πλαίσιο για τη δημιουργία δοκιμών, επιτρέποντάς μας να εστιάσουμε στη λειτουργικότητα που θέλουμε να ελέγξουμε χωρίς περιττή πολυπλοκότητα.

Η λογική που ακολουθήσαμε στα tests βασίζεται στο μοτίβο Arrange-Act-Assert:

1. Arrange: Ρυθμίζουμε την κατάσταση των δεδομένων για να προετοιμάσουμε το περιβάλλον δοκιμής. Δημιουργούμε τα απαραίτητα αντικείμενα και αρχικοποιούμε τις μεταβλητές.

2. Act: Εφαρμόζουμε μια μέθοδο ή μια λειτουργία στα δεδομένα που θα εκτελέσει τη δράση που θέλουμε να δοκιμάσουμε.

3. Assert: Ελέγχουμε ότι το αποτέλεσμα της δράσης είναι αυτό που περιμένουμε, χρησιμοποιώντας τις συναρτήσεις επιβεβαίωσης του acutest.h.

Στα παρακάτω αρχεία test_*.cpp, έχουμε δημιουργήσει unit tests για να επαληθεύσουμε τη σωστή λειτουργία των κύριων μεθόδων του κώδικά μας όπου κάθε test επικεντρώνεται σε συγκεκριμένη λειτουργία:
1. test_addEdge.cpp: Ελέγχει την προσθήκη ακμής μεταξύ δύο κόμβων στον γράφο και την ακρίβεια των γειτόνων.
2. test_addVertex.cpp: Ελέγχει την προσθήκη ενός νέου κόμβου στον γράφο και την ακρίβεια των δεδομένων του.
3. test_medoid.cpp: Ελέγχει την ακρίβεια εύρεσης του medoid μέσω δειγματοληψίας σε μεγάλο σύνολο δεδομένων.
4. test_greedySearch.cpp: Ελέγχει τη λειτουργία της άπληστης αναζήτησης για εύρεση πλησιέστερων γειτόνων.
5. test_robustPrune.cpp: Ελέγχει τη λειτουργία κλαδέματος των γειτόνων για έναν κόμβο, βάσει του αλγορίθμου robustPrune.
6. test_vamana.cpp: Ελέγχει την πλήρη λειτουργία του αλγορίθμου Vamana για σωστή κατασκευή και πλοήγηση στον γράφο. 
7. test_filterannimport.cpp: Ελέγχει την εισαγωγή και εξαγωγή φιλτραρισμένου ευρετηρίου (Import/Export), επαληθεύοντας την ακεραιότητα των δεδομένων. 
8. test_findMedoid.cpp: Ελέγχει την εύρεση medoid σε περίπτωση πολλαπλών φίλτρων και τη σωστή επιλογή σημείου.
9. test_filter_greedySearch.cpp: Ελέγχει την φιλτραρισμένη αναζήτηση μέσω GreedySearch, επαληθεύοντας την ορθότητα φιλτραρίσματος των αποτελεσμάτων.
10. test_filteredRobustPrune.cpp:Ελέγχει την προσαρμοσμένη λειτουργία RobustPrune όταν υπάρχουν φίλτρα και ετικέτες, ώστε να διατηρούνται μόνο οι σχετικοί γείτονες.
11. test_filter_vamana.cpp: Ελέγχει τον προσαρμοσμένο αλγόριθμο FilteredVamana για κατασκευή ευρετηρίου με φίλτρα.
12. test_stitched_vamana.cpp: Ελέγχει την ορθή stitching πολλαπλών γράφων Vamana σε ένα τελικό φιλτραρισμένο ευρετήριο.

Συνολικά, η προσέγγισή μας στα unit tests μάς επέτρεψε να διασφαλίσουμε την ορθότητα και την αξιοπιστία της υλοποίησής μας.

--------------

## Build Mechanism Description

Η δημιουργία του οποιουδήποτε νέου εκτελέσιμου με όνομα \<TARGET\> ακολουθεί την εξής διαδικασία:
1. Δημιουργία του φακέλου **src/main/cpp/\<TARGET\>**
2. Δημιουργία **-μοναδικού στο φάκελο(και τους υποφακέλους του)**- αρχείου **main.cpp**
3. Δημιουργία λοιπών αρχείων που χρειάζεται το εκτελέσιμο 
4. Δημιουργία στον φάκελο configs/ του αρχείου \<TARGET\>.mk.config με την ακόλουθη δομή:

--------------

\# build config \
TARGET = \<TARGET\> \
DEPENDENCIES = DEPENDENCIES(\<TARGET\>) \# e.g \$(shell find \$(SRC_DIR)/utility -name "*.cpp")

\# arguments \
\<ARG1\> = ARG_VAL1 \
...

\# command line arguments \
\<TARGET\>_CLINE_ARGS = $(<ARG1>) ... ARG_VALN

#### NOTE: No need to list in "DEPENDENCIES" the files existing in **src/main/cpp/\<TARGET\>**

--------------
