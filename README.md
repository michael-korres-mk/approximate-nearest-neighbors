# approximate-nearest-neighbors - Kyndinis Marios - sdi2000223 & Korres Michail - sdi2000092 - uoa - di

### Build Project
```
make
```

### Run Project
```
make ann
```

### Run Project with Valgrind
```
make valgrind-ann
```

### Clean
```
make clean
```

## About the project

### Introduction

Στην παρούσα υλοποίηση αναπτύξαμε έναν αλγόριθμο βασισμένο στο Vamana για την αποδοτική εύρεση των κατά προσέγγιση πλησιέστερων γειτόνων σε μεγάλα σύνολα δεδομένων υψηλής διάστασης. Εστιάσαμε ιδιαίτερα στη βασική μέθοδο vamana(), η οποία αποτελεί τον πυρήνα του αλγορίθμου μας και καθορίζει την αποτελεσματικότητά του.

### Description of the Algorithm

Η μέθοδος vamana() είναι υπεύθυνη για την κατασκευή του γράφου. Αρχικά, μέσω της initializeRandomEdges(), αρχικοποιήσαμε τον γράφο με τυχαίες ακμές, εξασφαλίζοντας ότι κάθε κόμβος έχει ένα αρχικό σύνολο γειτόνων και ότι ο γράφος είναι συνδεδεμένος. Στη συνέχεια, υπολογίσαμε το medoid του συνόλου δεδομένων με τη μέθοδο medoid(), η οποία επιλέγει ένα σημείο που ελαχιστοποιεί τη συνολική απόσταση από τα υπόλοιπα σημεία.

Στον κύριο βρόχο της vamana(), για κάθε κόμβο που δεν έχει ακόμα επεξεργαστεί, εκτελέσαμε μια άπληστη αναζήτηση ξεκινώντας από το medoid, χρησιμοποιώντας τη μέθοδο greedySearch(). Η greedySearch() ξεκινά από έναν αρχικό κόμβο s και αναζητά τους πλησιέστερους γείτονες για ένα δοσμένο διάνυσμα ερώτησης q. Χρησιμοποιήσαμε μια δομή VamanaContainer l για να αποθηκεύουμε τους υποψήφιους κόμβους με βάση την απόστασή τους από το q, και ένα σύνολο V για τους κόμβους που έχουν ήδη επισκεφθεί. Με αυτόν τον τρόπο, διατηρήσαμε ένα ισορροπημένο σύνολο υποψήφιων κόμβων προς εξέταση, αποφεύγοντας επανειλημμένες επισκέψεις και βελτιστοποιώντας την απόδοση.

Κατά την αναζήτηση, επεκτείναμε το σύνολο l με τους γείτονες του τρέχοντος κόμβου που δεν είχαν ήδη επισκεφθεί. Επιλέγαμε τον κόμβο με τη μικρότερη απόσταση από το q και επαναλαμβάναμε τη διαδικασία μέχρι να μην υπάρχουν άλλοι υποψήφιοι κόμβοι. Αυτό επέτρεψε την αποδοτική πλοήγηση στον γράφο και την εύρεση των πιο σχετικών κόμβων σε σχέση με το q.

Μετά την ολοκλήρωση της άπληστης αναζήτησης για έναν κόμβο, εφαρμόσαμε τη μέθοδο robustPrune() για να βελτιστοποιήσουμε το σύνολο των γειτόνων του. Η μέθοδος robustPrune() δέχεται ως είσοδο έναν κόμβο p, ένα σύνολο υποψήφιων γειτόνων V, την παράμετρο α, και το μέγιστο επιτρεπτό βαθμό R. Μέσω αυτής της διαδικασίας, εφαρμόζουμε ένα κλάδεμα στους υποψήφιους γείτονες ώστε να διατηρήσουμε μόνο τους πιο σημαντικούς, βάσει της απόστασης και του κατωφλίου α. Συγκεκριμένα, επιλέγουμε τον πλησιέστερο γείτονα και αφαιρούμε από το σύνολο των υποψήφιων όσους δεν πληρούν το κριτήριο απόστασης που ορίζει το α. Αυτό μας επέτρεψε να διατηρήσουμε τον γράφο αραιό αλλά ταυτόχρονα αποδοτικό για την αναζήτηση, καθώς περιορίζει τον αριθμό των ακμών ανά κόμβο χωρίς να θυσιάζει την ποιότητα της αναζήτησης. Έτσι, εξασφαλίζουμε ότι κάθε κόμβος συνδέεται με τους πιο σχετικούς γείτονες, βελτιώνοντας την ταχύτητα και την ακρίβεια του αλγορίθμου.

Κατά την αξιολόγηση της απόδοσης του αλγορίθμου, φορτώσαμε τα σύνολα δεδομένων βάσης, ερωτήσεων και ground truth χρησιμοποιώντας την κλάση DataSet. Για κάθε διάνυσμα ερώτησης, εκτελέσαμε την αναζήτηση στον γράφο και συγκρίναμε τα αποτελέσματα με το ground truth. Υπολογίσαμε το k-recall, που είναι το ποσοστό των πραγματικών πλησιέστερων γειτόνων που βρέθηκαν από τον αλγόριθμο. Τα αποτελέσματα έδειξαν υψηλό επίπεδο ακρίβειας, επιβεβαιώνοντας την αποτελεσματικότητα της προσέγγισής μας.

Στον κώδικα, χρησιμοποιήσαμε επίσης την κλάση Utils για διάφορες βοηθητικές λειτουργίες, όπως η δημιουργία τυχαίων αριθμών και η εκτύπωση διαχωριστικών γραμμών για την καλύτερη αναγνωσιμότητα των εξόδων. Επιπλέον, επιλέξαμε να χρησιμοποιήσουμε πρότυπα (templates) για την κλάση Graph, ώστε να υποστηρίζουμε διαφορετικούς τύπους δεδομένων χωρίς να χρειάζεται να επαναλάβουμε τον κώδικα.

Δώσαμε ιδιαίτερη προσοχή στη διαχείριση της μνήμης και την αποφυγή διαρροών, χρησιμοποιώντας κατάλληλες δομές δεδομένων και εξασφαλίζοντας ότι όλες οι δυναμικές μνήμες απελευθερώνονται σωστά. Ο συνάδελφός μου και εγώ φροντίσαμε ο κώδικας να είναι καλά σχολιασμένος και δομημένος, ώστε να είναι εύκολα κατανοητός και επεκτάσιμος στο μέλλον.

## Unit Tests
### Build Project - Unit Test
```
make
```

### Run Unit Test
```
make tests
```

### Project Contribution
Michael Korres
* Project Setup (Project File-Structure, Data Input & Core Implementations)
* GreedySearch Implementation
* Vamana Implementation

Marios Kindynis
* RobustPrune Implementation
* Implementation Optimizations & Fixes
* Testing
* Commenting & README

### Description

Για την υλοποίηση των unit tests, δημιουργήσαμε ένα Makefile που αυτοματοποιεί τη διαδικασία κατασκευής και εκτέλεσης των δοκιμών μας. Το Makefile εντοπίζει όλα τα αρχεία .cpp στον φάκελο tests και δημιουργεί τα αντίστοιχα εκτελέσιμα στον φάκελο build/tests. Έτσι, με μία μόνο εντολή, μπορούμε να κατασκευάσουμε και να εκτελέσουμε όλα τα tests, εξοικονομώντας χρόνο και αποφεύγοντας πιθανά λάθη. Με αυτόν τον τρόπο, μπορούμε να προσθέτουμε νέα tests απλά δημιουργώντας ένα νέο αρχείο .cpp στον φάκελο tests, χωρίς να χρειάζεται να τροποποιούμε το Makefile.

Χρησιμοποιήσαμε τη βιβλιοθήκη acutest.h για τη συγγραφή των unit tests. Το acutest.h μας παρέχει ένα απλό και ευέλικτο πλαίσιο για τη δημιουργία δοκιμών, επιτρέποντάς μας να εστιάσουμε στη λειτουργικότητα που θέλουμε να ελέγξουμε χωρίς περιττή πολυπλοκότητα.

Η λογική που ακολουθήσαμε στα tests βασίζεται στο μοτίβο Arrange-Act-Assert:

1. Arrange: Ρυθμίζουμε την κατάσταση των δεδομένων για να προετοιμάσουμε το περιβάλλον δοκιμής. Δημιουργούμε τα απαραίτητα αντικείμενα και αρχικοποιούμε τις μεταβλητές.

2. Act: Εφαρμόζουμε μια μέθοδο ή μια λειτουργία στα δεδομένα που θα εκτελέσει τη δράση που θέλουμε να δοκιμάσουμε.

3. Assert: Ελέγχουμε ότι το αποτέλεσμα της δράσης είναι αυτό που περιμένουμε, χρησιμοποιώντας τις συναρτήσεις επιβεβαίωσης του acutest.h.

Στα παρακάτω αρχεία test_*.cpp, έχουμε δημιουργήσει unit tests για να επαληθεύσουμε τη σωστή λειτουργία των κύριων μεθόδων του κώδικά μας όπου κάθε test επικεντρώνεται σε συγκεκριμένη λειτουργία:
1. test_addEdge.cpp: Ελέγχει την προσθήκη ακμής μεταξύ δύο κόμβων στον γράφο και την ακρίβεια των γειτόνων.

2. test_weightAddedProperly.cpp: Επαληθεύει ότι το βάρος της ακμής που προστίθεται υπολογίζεται σωστά.

3. test_addVertex.cpp: Δοκιμάζει την προσθήκη ενός νέου κόμβου στον γράφο και την ακρίβεια των δεδομένων του.

4. test_invalidIdIsNullptr.cpp: Ελέγχει την επιστροφή κενού διανύσματος όταν ζητείται κόμβος με μη έγκυρο ID.

5. test_greedySearch.cpp: Δοκιμάζει τη λειτουργία της άπληστης αναζήτησης για εύρεση πλησιέστερων γειτόνων.

6. test_medoid.cpp: Ελέγχει την ακρίβεια εύρεσης του medoid μέσω δειγματοληψίας σε μεγάλο σύνολο δεδομένων.

7. test_robustPrune.cpp: Δοκιμάζει τη λειτουργία κλαδέματος των γειτόνων για έναν κόμβο, βάσει του αλγορίθμου robustPrune.

8. test_vamana.cpp: Ελέγχει την πλήρη λειτουργία του αλγορίθμου Vamana για σωστή κατασκευή και πλοήγηση στον γράφο.

Συνολικά, η προσέγγισή μας στα unit tests μάς επέτρεψε να διασφαλίσουμε την ορθότητα και την αξιοπιστία της υλοποίησής μας. 
